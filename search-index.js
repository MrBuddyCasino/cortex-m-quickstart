var searchIndex = {};
searchIndex["aligned"] = {"doc":"Statically allocated arrays with guaranteed memory alignments","items":[[3,"Aligned","aligned","An `ARRAY` aligned to `mem::align_of::<ALIGNMENT>()` bytes",null,null],[12,"array","","The array",0,null],[5,"Aligned","","`Aligned` constructor",null,{"inputs":[{"name":"array"}],"output":{"name":"aligned"}}],[8,"Alignment","","IMPLEMENTATION DETAIL",null,null],[11,"deref","","",0,null],[11,"deref_mut","","",0,null],[11,"deref","","",0,null],[11,"deref_mut","","",0,null],[11,"index","","",0,null],[11,"index_mut","","",0,null],[11,"deref","","",0,null],[11,"deref_mut","","",0,null],[11,"index","","",0,null],[11,"index_mut","","",0,null],[11,"deref","","",0,null],[11,"deref_mut","","",0,null],[11,"index","","",0,null],[11,"index_mut","","",0,null],[11,"deref","","",0,null],[11,"deref_mut","","",0,null],[11,"index","","",0,null],[11,"index_mut","","",0,null],[11,"deref","","",0,null],[11,"deref_mut","","",0,null],[11,"index","","",0,null],[11,"index_mut","","",0,null],[11,"deref","","",0,null],[11,"deref_mut","","",0,null],[11,"index","","",0,null],[11,"index_mut","","",0,null],[11,"deref","","",0,null],[11,"deref_mut","","",0,null],[11,"index","","",0,null],[11,"index_mut","","",0,null],[11,"deref","","",0,null],[11,"deref_mut","","",0,null],[11,"index","","",0,null],[11,"index_mut","","",0,null],[11,"deref","","",0,null],[11,"deref_mut","","",0,null],[11,"index","","",0,null],[11,"index_mut","","",0,null],[11,"deref","","",0,null],[11,"deref_mut","","",0,null],[11,"index","","",0,null],[11,"index_mut","","",0,null],[11,"deref","","",0,null],[11,"deref_mut","","",0,null],[11,"index","","",0,null],[11,"index_mut","","",0,null],[11,"deref","","",0,null],[11,"deref_mut","","",0,null],[11,"index","","",0,null],[11,"index_mut","","",0,null],[11,"deref","","",0,null],[11,"deref_mut","","",0,null],[11,"index","","",0,null],[11,"index_mut","","",0,null],[11,"deref","","",0,null],[11,"deref_mut","","",0,null],[11,"index","","",0,null],[11,"index_mut","","",0,null],[11,"deref","","",0,null],[11,"deref_mut","","",0,null],[11,"index","","",0,null],[11,"index_mut","","",0,null],[11,"deref","","",0,null],[11,"deref_mut","","",0,null],[11,"index","","",0,null],[11,"index_mut","","",0,null],[11,"deref","","",0,null],[11,"deref_mut","","",0,null],[11,"index","","",0,null],[11,"index_mut","","",0,null],[11,"deref","","",0,null],[11,"deref_mut","","",0,null],[11,"index","","",0,null],[11,"index_mut","","",0,null],[11,"deref","","",0,null],[11,"deref_mut","","",0,null],[11,"index","","",0,null],[11,"index_mut","","",0,null],[11,"deref","","",0,null],[11,"deref_mut","","",0,null],[11,"index","","",0,null],[11,"index_mut","","",0,null],[11,"deref","","",0,null],[11,"deref_mut","","",0,null],[11,"index","","",0,null],[11,"index_mut","","",0,null],[11,"deref","","",0,null],[11,"deref_mut","","",0,null],[11,"index","","",0,null],[11,"index_mut","","",0,null],[11,"deref","","",0,null],[11,"deref_mut","","",0,null],[11,"index","","",0,null],[11,"index_mut","","",0,null],[11,"deref","","",0,null],[11,"deref_mut","","",0,null],[11,"index","","",0,null],[11,"index_mut","","",0,null],[11,"deref","","",0,null],[11,"deref_mut","","",0,null],[11,"index","","",0,null],[11,"index_mut","","",0,null],[11,"deref","","",0,null],[11,"deref_mut","","",0,null],[11,"index","","",0,null],[11,"index_mut","","",0,null],[11,"deref","","",0,null],[11,"deref_mut","","",0,null],[11,"index","","",0,null],[11,"index_mut","","",0,null],[11,"deref","","",0,null],[11,"deref_mut","","",0,null],[11,"index","","",0,null],[11,"index_mut","","",0,null],[11,"deref","","",0,null],[11,"deref_mut","","",0,null],[11,"index","","",0,null],[11,"index_mut","","",0,null],[11,"deref","","",0,null],[11,"deref_mut","","",0,null],[11,"index","","",0,null],[11,"index_mut","","",0,null],[11,"deref","","",0,null],[11,"deref_mut","","",0,null],[11,"index","","",0,null],[11,"index_mut","","",0,null],[11,"deref","","",0,null],[11,"deref_mut","","",0,null],[11,"index","","",0,null],[11,"index_mut","","",0,null],[11,"deref","","",0,null],[11,"deref_mut","","",0,null],[11,"index","","",0,null],[11,"index_mut","","",0,null],[11,"deref","","",0,null],[11,"deref_mut","","",0,null],[11,"index","","",0,null],[11,"index_mut","","",0,null],[11,"deref","","",0,null],[11,"deref_mut","","",0,null],[11,"index","","",0,null],[11,"index_mut","","",0,null],[11,"deref","","",0,null],[11,"deref_mut","","",0,null],[11,"index","","",0,null],[11,"index_mut","","",0,null],[11,"deref","","",0,null],[11,"deref_mut","","",0,null],[11,"index","","",0,null],[11,"index_mut","","",0,null]],"paths":[[3,"Aligned"]]};
searchIndex["alloc_cortex_m"] = {"doc":"A heap allocator for Cortex-M processors","items":[[3,"CortexMHeap","alloc_cortex_m","",null,null],[11,"empty","","Crate a new UNINITIALIZED heap allocator",0,{"inputs":[],"output":{"name":"cortexmheap"}}],[11,"init","","Initializes the heap",0,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"}],"output":null}],[11,"alloc","","",0,null],[11,"dealloc","","",0,null]],"paths":[[3,"CortexMHeap"]]};
searchIndex["bare_metal"] = {"doc":"Abstractions common to bare metal systems","items":[[3,"Peripheral","bare_metal","A peripheral",null,null],[3,"CriticalSection","","Critical section token",null,null],[3,"Mutex","","A \"mutex\" based on critical sections",null,null],[8,"Nr","","Interrupt number",null,null],[10,"nr","","Returns the number associated with an interrupt",0,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Creates a new peripheral",1,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"borrow","","Borrows the peripheral for the duration of a critical section",1,{"inputs":[{"name":"self"},{"name":"criticalsection"}],"output":{"name":"t"}}],[11,"get","","Returns a pointer to the register block",1,null],[11,"new","","Creates a critical section token",2,{"inputs":[],"output":{"name":"self"}}],[11,"new","","Creates a new mutex",3,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[11,"borrow","","Borrows the data for the duration of the critical section",3,{"inputs":[{"name":"self"},{"name":"criticalsection"}],"output":{"name":"t"}}]],"paths":[[8,"Nr"],[3,"Peripheral"],[3,"CriticalSection"],[3,"Mutex"]]};
searchIndex["cortex_m"] = {"doc":"Low level access to Cortex-M processors","items":[[0,"asm","cortex_m","Miscellaneous assembly instructions",null,null],[5,"bkpt","cortex_m::asm","Puts the processor in Debug state. Debuggers can pick this up as a \"breakpoint\".",null,{"inputs":[],"output":null}],[5,"nop","","A no-operation. Useful to prevent delay loops from being optimized away.",null,{"inputs":[],"output":null}],[5,"wfe","","Wait For Event",null,{"inputs":[],"output":null}],[5,"wfi","","Wait For Interrupt",null,{"inputs":[],"output":null}],[5,"sev","","Send Event",null,{"inputs":[],"output":null}],[5,"isb","","Instruction Synchronization Barrier",null,{"inputs":[],"output":null}],[5,"dsb","","Data Synchronization Barrier",null,{"inputs":[],"output":null}],[5,"dmb","","Data Memory Barrier",null,{"inputs":[],"output":null}],[0,"exception","cortex_m","Exceptions",null,null],[3,"ExceptionFrame","cortex_m::exception","Registers stacked (pushed into the stack) during an exception",null,null],[12,"r0","","(General purpose) Register 0",0,null],[12,"r1","","(General purpose) Register 1",0,null],[12,"r2","","(General purpose) Register 2",0,null],[12,"r3","","(General purpose) Register 3",0,null],[12,"r12","","(General purpose) Register 12",0,null],[12,"lr","","Linker Register",0,null],[12,"pc","","Program Counter",0,null],[12,"xpsr","","Program Status Register",0,null],[4,"Exception","","Enumeration of all the exception types",null,null],[13,"NMI","","Non-maskable interrupt",1,null],[13,"HardFault","","Other type of faults and unhandled faults",1,null],[13,"MenManage","","Memory protection related fault",1,null],[13,"BusFault","","Pre-fetch or memory access fault",1,null],[13,"UsageFault","","Fault due to undefined instruction or illegal state",1,null],[13,"SVCall","","Supervisor call",1,null],[13,"PendSV","","Pendable request for system-level service",1,null],[13,"SysTick","","System timer exception",1,null],[13,"Interrupt","","An interrupt",1,null],[11,"clone","","",1,{"inputs":[{"name":"self"}],"output":{"name":"exception"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",1,{"inputs":[{"name":"self"},{"name":"exception"}],"output":{"name":"bool"}}],[11,"ne","","",1,{"inputs":[{"name":"self"},{"name":"exception"}],"output":{"name":"bool"}}],[11,"active","","Returns the type of the exception that's currently active",1,{"inputs":[],"output":{"generics":["exception"],"name":"option"}}],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"exceptionframe"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[0,"interrupt","cortex_m","Interrupts",null,null],[3,"CriticalSection","cortex_m::interrupt","Critical section token",null,null],[3,"Mutex","","A \"mutex\" based on critical sections",null,null],[8,"Nr","","Interrupt number",null,null],[10,"nr","","Returns the number associated with an interrupt",2,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[5,"disable","","Disables all interrupts",null,{"inputs":[],"output":null}],[5,"enable","","Enables all the interrupts",null,{"inputs":[],"output":null}],[5,"free","","Execute closure `f` in an interrupt-free context.",null,{"inputs":[{"name":"f"}],"output":{"name":"r"}}],[0,"itm","cortex_m","Instrumentation Trace Macrocell",null,null],[5,"write_all","cortex_m::itm","Writes a `buffer` to the ITM `port`",null,null],[5,"write_aligned","","Writes a 4-byte aligned `buffer` to the ITM `port`",null,{"inputs":[{"name":"stim"},{"name":"aligned"}],"output":null}],[5,"write_fmt","","Writes `fmt::Arguments` to the ITM `port`",null,{"inputs":[{"name":"stim"},{"name":"arguments"}],"output":null}],[5,"write_str","","Writes a string to the ITM `port`",null,{"inputs":[{"name":"stim"},{"name":"str"}],"output":null}],[0,"peripheral","cortex_m","Core peripherals",null,null],[3,"Peripherals","cortex_m::peripheral","Core peripherals",null,null],[12,"CBP","","Cache and branch predictor maintenance operations",3,null],[12,"CPUID","","CPUID",3,null],[12,"DCB","","Debug Control Block",3,null],[12,"DWT","","Data Watchpoint and Trace unit",3,null],[12,"FPB","","Flash Patch and Breakpoint unit",3,null],[12,"FPU","","Floating Point Unit",3,null],[12,"ITM","","Instrumentation Trace Macrocell",3,null],[12,"MPU","","Memory Protection Unit",3,null],[12,"NVIC","","Nested Vector Interrupt Controller",3,null],[12,"SCB","","System Control Block",3,null],[12,"SYST","","SysTick: System Timer",3,null],[12,"TPIU","","Trace Port Interface Unit;",3,null],[3,"CBP","","Cache and branch predictor maintenance operations",null,null],[3,"CPUID","","CPUID",null,null],[3,"DCB","","Debug Control Block",null,null],[3,"DWT","","Data Watchpoint and Trace unit",null,null],[3,"FPB","","Flash Patch and Breakpoint unit",null,null],[3,"FPU","","Floating Point Unit",null,null],[3,"ITM","","Instrumentation Trace Macrocell",null,null],[3,"MPU","","Memory Protection Unit",null,null],[3,"NVIC","","Nested Vector Interrupt Controller",null,null],[3,"SCB","","System Control Block",null,null],[3,"SYST","","SysTick: System Timer",null,null],[3,"TPIU","","Trace Port Interface Unit;",null,null],[0,"cbp","","Cache and branch predictor maintenance operations",null,null],[3,"RegisterBlock","cortex_m::peripheral::cbp","Register block",null,null],[12,"iciallu","","I-cache invalidate all to PoU",4,null],[12,"icimvau","","I-cache invalidate by MVA to PoU",4,null],[12,"dcimvac","","D-cache invalidate by MVA to PoC",4,null],[12,"dcisw","","D-cache invalidate by set-way",4,null],[12,"dccmvau","","D-cache clean by MVA to PoU",4,null],[12,"dccmvac","","D-cache clean by MVA to PoC",4,null],[12,"dccsw","","D-cache clean by set-way",4,null],[12,"dccimvac","","D-cache clean and invalidate by MVA to PoC",4,null],[12,"dccisw","","D-cache clean and invalidate by set-way",4,null],[12,"bpiall","","Branch predictor invalidate all",4,null],[11,"iciallu","cortex_m::peripheral","I-cache invalidate all to PoU",5,{"inputs":[{"name":"self"}],"output":null}],[11,"icimvau","","I-cache invalidate by MVA to PoU",5,{"inputs":[{"name":"self"},{"name":"u32"}],"output":null}],[11,"dcimvac","","D-cache invalidate by MVA to PoC",5,{"inputs":[{"name":"self"},{"name":"u32"}],"output":null}],[11,"dcisw","","D-cache invalidate by set-way",5,{"inputs":[{"name":"self"},{"name":"u16"},{"name":"u16"}],"output":null}],[11,"dccmvau","","D-cache clean by MVA to PoU",5,{"inputs":[{"name":"self"},{"name":"u32"}],"output":null}],[11,"dccmvac","","D-cache clean by MVA to PoC",5,{"inputs":[{"name":"self"},{"name":"u32"}],"output":null}],[11,"dccsw","","D-cache clean by set-way",5,{"inputs":[{"name":"self"},{"name":"u16"},{"name":"u16"}],"output":null}],[11,"dccimvac","","D-cache clean and invalidate by MVA to PoC",5,{"inputs":[{"name":"self"},{"name":"u32"}],"output":null}],[11,"dccisw","","D-cache clean and invalidate by set-way",5,{"inputs":[{"name":"self"},{"name":"u16"},{"name":"u16"}],"output":null}],[11,"bpiall","","Branch predictor invalidate all",5,{"inputs":[{"name":"self"}],"output":null}],[0,"cpuid","","CPUID",null,null],[3,"RegisterBlock","cortex_m::peripheral::cpuid","Register block",null,null],[12,"base","","CPUID base",6,null],[12,"pfr","","Processor Feature",6,null],[12,"dfr","","Debug Feature",6,null],[12,"afr","","Auxiliary Feature",6,null],[12,"mmfr","","Memory Model Feature",6,null],[12,"isar","","Instruction Set Attribute",6,null],[12,"clidr","","Cache Level ID",6,null],[12,"ctr","","Cache Type",6,null],[12,"ccsidr","","Cache Size ID",6,null],[12,"csselr","","Cache Size Selection",6,null],[4,"CsselrCacheType","","Type of cache to select on CSSELR writes.",null,null],[13,"DataOrUnified","","Select DCache or unified cache",7,null],[13,"Instruction","","Select ICache",7,null],[11,"select_cache","cortex_m::peripheral","Selects the current CCSIDR",8,{"inputs":[{"name":"self"},{"name":"u8"},{"name":"csselrcachetype"}],"output":null}],[11,"cache_num_sets_ways","","Returns the number of sets and ways in the selected cache",8,null],[0,"dcb","","Debug Control Block",null,null],[3,"RegisterBlock","cortex_m::peripheral::dcb","Register block",null,null],[12,"dhcsr","","Debug Halting Control and Status",9,null],[12,"dcrsr","","Debug Core Register Selector",9,null],[12,"dcrdr","","Debug Core Register Data",9,null],[12,"demcr","","Debug Exception and Monitor Control",9,null],[0,"dwt","cortex_m::peripheral","Data Watchpoint and Trace unit",null,null],[3,"RegisterBlock","cortex_m::peripheral::dwt","Register block",null,null],[12,"ctrl","","Control",10,null],[12,"cyccnt","","Cycle Count",10,null],[12,"cpicnt","","CPI Count",10,null],[12,"exccnt","","Exception Overhead Count",10,null],[12,"sleepcnt","","Sleep Count",10,null],[12,"lsucnt","","LSU Count",10,null],[12,"foldcnt","","Folded-instruction Count",10,null],[12,"pcsr","","Program Counter Sample",10,null],[12,"c","","Comparators",10,null],[12,"lar","","Lock Access",10,null],[12,"lsr","","Lock Status",10,null],[3,"Comparator","","Comparator",null,null],[12,"comp","","Comparator",11,null],[12,"mask","","Comparator Mask",11,null],[12,"function","","Comparator Function",11,null],[11,"enable_cycle_counter","cortex_m::peripheral","Enables the cycle counter",12,{"inputs":[{"name":"self"}],"output":null}],[11,"get_cycle_count","","Returns the current clock cycle count",12,{"inputs":[],"output":{"name":"u32"}}],[0,"fpb","","Flash Patch and Breakpoint unit",null,null],[3,"RegisterBlock","cortex_m::peripheral::fpb","Register block",null,null],[12,"ctrl","","Control",13,null],[12,"remap","","Remap",13,null],[12,"comp","","Comparator",13,null],[12,"lar","","Lock Access",13,null],[12,"lsr","","Lock Status",13,null],[0,"fpu","cortex_m::peripheral","Floating Point Unit",null,null],[3,"RegisterBlock","cortex_m::peripheral::fpu","Register block",null,null],[12,"fpccr","","Floating Point Context Control",14,null],[12,"fpcar","","Floating Point Context Address",14,null],[12,"fpdscr","","Floating Point Default Status Control",14,null],[12,"mvfr","","Media and FP Feature",14,null],[0,"itm","cortex_m::peripheral","Instrumentation Trace Macrocell",null,null],[3,"RegisterBlock","cortex_m::peripheral::itm","Register block",null,null],[12,"stim","","Stimulus Port",15,null],[12,"ter","","Trace Enable",15,null],[12,"tpr","","Trace Privilege",15,null],[12,"tcr","","Trace Control",15,null],[12,"lar","","Lock Access",15,null],[12,"lsr","","Lock Status",15,null],[3,"Stim","","Stimulus Port",null,null],[11,"write_u8","","Writes an `u8` payload into the stimulus port",16,{"inputs":[{"name":"self"},{"name":"u8"}],"output":null}],[11,"write_u16","","Writes an `u16` payload into the stimulus port",16,{"inputs":[{"name":"self"},{"name":"u16"}],"output":null}],[11,"write_u32","","Writes an `u32` payload into the stimulus port",16,{"inputs":[{"name":"self"},{"name":"u32"}],"output":null}],[11,"is_fifo_ready","","Returns `true` if the stimulus port is ready to accept more data",16,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[0,"mpu","cortex_m::peripheral","Memory Protection Unit",null,null],[3,"RegisterBlock","cortex_m::peripheral::mpu","Register block",null,null],[12,"_type","","Type",17,null],[12,"ctrl","","Control",17,null],[12,"rnr","","Region Number",17,null],[12,"rbar","","Region Base Address",17,null],[12,"rasr","","Region Attribute and Size",17,null],[12,"rbar_a1","","Alias 1 of RBAR",17,null],[12,"rsar_a1","","Alias 1 of RSAR",17,null],[12,"rbar_a2","","Alias 2 of RBAR",17,null],[12,"rsar_a2","","Alias 2 of RSAR",17,null],[12,"rbar_a3","","Alias 3 of RBAR",17,null],[12,"rsar_a3","","Alias 3 of RSAR",17,null],[0,"nvic","cortex_m::peripheral","Nested Vector Interrupt Controller",null,null],[3,"RegisterBlock","cortex_m::peripheral::nvic","Register block",null,null],[12,"iser","","Interrupt Set-Enable",18,null],[12,"icer","","Interrupt Clear-Enable",18,null],[12,"ispr","","Interrupt Set-Pending",18,null],[12,"icpr","","Interrupt Clear-Pending",18,null],[12,"iabr","","Interrupt Active Bit",18,null],[12,"ipr","","Interrupt Priority",18,null],[11,"clear_pending","cortex_m::peripheral","Clears `interrupt`'s pending state",19,{"inputs":[{"name":"self"},{"name":"i"}],"output":null}],[11,"disable","","Disables `interrupt`",19,{"inputs":[{"name":"self"},{"name":"i"}],"output":null}],[11,"enable","","Enables `interrupt`",19,{"inputs":[{"name":"self"},{"name":"i"}],"output":null}],[11,"get_priority","","Returns the NVIC priority of `interrupt`",19,{"inputs":[{"name":"i"}],"output":{"name":"u8"}}],[11,"is_active","","Is `interrupt` active or pre-empted and stacked",19,{"inputs":[{"name":"i"}],"output":{"name":"bool"}}],[11,"is_enabled","","Checks if `interrupt` is enabled",19,{"inputs":[{"name":"i"}],"output":{"name":"bool"}}],[11,"is_pending","","Checks if `interrupt` is pending",19,{"inputs":[{"name":"i"}],"output":{"name":"bool"}}],[11,"set_pending","","Forces `interrupt` into pending state",19,{"inputs":[{"name":"self"},{"name":"i"}],"output":null}],[11,"set_priority","","Sets the \"priority\" of `interrupt` to `prio`",19,{"inputs":[{"name":"self"},{"name":"i"},{"name":"u8"}],"output":null}],[0,"scb","","System Control Block",null,null],[3,"RegisterBlock","cortex_m::peripheral::scb","Register block",null,null],[12,"icsr","","Interrupt Control and State",20,null],[12,"vtor","","Vector Table Offset",20,null],[12,"aircr","","Application Interrupt and Reset Control",20,null],[12,"scr","","System Control",20,null],[12,"ccr","","Configuration and Control",20,null],[12,"shpr","","System Handler Priority",20,null],[12,"shpcrs","","System Handler Control and State",20,null],[12,"cfsr","","Configurable Fault Status",20,null],[12,"hfsr","","HardFault Status",20,null],[12,"dfsr","","Debug Fault Status",20,null],[12,"mmar","","MemManage Fault Address",20,null],[12,"bfar","","BusFault Address",20,null],[12,"afsr","","Auxiliary Fault Status",20,null],[12,"cpacr","","Coprocessor Access Control",20,null],[11,"enable_icache","cortex_m::peripheral","Enables I-Cache if currently disabled",21,{"inputs":[{"name":"self"}],"output":null}],[11,"disable_icache","","Disables I-Cache if currently enabled",21,{"inputs":[{"name":"self"}],"output":null}],[11,"icache_enabled","","Returns whether the I-Cache is currently enabled",21,{"inputs":[],"output":{"name":"bool"}}],[11,"invalidate_icache","","Invalidates I-Cache",21,{"inputs":[{"name":"self"}],"output":null}],[11,"enable_dcache","","Enables D-cache if currently disabled",21,{"inputs":[{"name":"self"},{"name":"cpuid"}],"output":null}],[11,"disable_dcache","","Disables D-cache if currently enabled",21,{"inputs":[{"name":"self"},{"name":"cpuid"}],"output":null}],[11,"dcache_enabled","","Returns whether the D-Cache is currently enabled",21,{"inputs":[],"output":{"name":"bool"}}],[11,"clean_dcache","","Cleans D-cache",21,{"inputs":[{"name":"self"},{"name":"cpuid"}],"output":null}],[11,"clean_invalidate_dcache","","Cleans and invalidates D-cache",21,{"inputs":[{"name":"self"},{"name":"cpuid"}],"output":null}],[11,"invalidate_dcache_by_address","","Invalidates D-cache by address",21,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"}],"output":null}],[11,"clean_dcache_by_address","","Cleans D-cache by address",21,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"}],"output":null}],[11,"clean_invalidate_dcache_by_address","","Cleans and invalidates D-cache by address",21,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"}],"output":null}],[0,"syst","","SysTick: System Timer",null,null],[3,"RegisterBlock","cortex_m::peripheral::syst","Register block",null,null],[12,"csr","","Control and Status",22,null],[12,"rvr","","Reload Value",22,null],[12,"cvr","","Current Value",22,null],[12,"calib","","Calibration Value",22,null],[4,"SystClkSource","","SysTick clock source",null,null],[13,"Core","","Core-provided clock",23,null],[13,"External","","External reference clock",23,null],[11,"clone","","",23,{"inputs":[{"name":"self"}],"output":{"name":"systclksource"}}],[11,"fmt","","",23,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clear_current","cortex_m::peripheral","Clears current value to 0",24,{"inputs":[{"name":"self"}],"output":null}],[11,"disable_counter","","Disables counter",24,{"inputs":[{"name":"self"}],"output":null}],[11,"disable_interrupt","","Disables SysTick interrupt",24,{"inputs":[{"name":"self"}],"output":null}],[11,"enable_counter","","Enables counter",24,{"inputs":[{"name":"self"}],"output":null}],[11,"enable_interrupt","","Enables SysTick interrupt",24,{"inputs":[{"name":"self"}],"output":null}],[11,"get_clock_source","","Gets clock source",24,{"inputs":[{"name":"self"}],"output":{"name":"systclksource"}}],[11,"get_current","","Gets current value",24,{"inputs":[],"output":{"name":"u32"}}],[11,"get_reload","","Gets reload value",24,{"inputs":[],"output":{"name":"u32"}}],[11,"get_ticks_per_10ms","","Returns the reload value with which the counter would wrap once per 10 ms",24,{"inputs":[],"output":{"name":"u32"}}],[11,"has_reference_clock","","Checks if an external reference clock is available",24,{"inputs":[],"output":{"name":"bool"}}],[11,"has_wrapped","","Checks if the counter wrapped (underflowed) since the last check",24,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_counter_enabled","","Checks if counter is enabled",24,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_interrupt_enabled","","Checks if SysTick interrupt is enabled",24,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_precise","","Checks if the calibration value is precise",24,{"inputs":[],"output":{"name":"bool"}}],[11,"set_clock_source","","Sets clock source",24,{"inputs":[{"name":"self"},{"name":"systclksource"}],"output":null}],[11,"set_reload","","Sets reload value",24,{"inputs":[{"name":"self"},{"name":"u32"}],"output":null}],[0,"tpiu","","Trace Port Interface Unit;",null,null],[3,"RegisterBlock","cortex_m::peripheral::tpiu","Register block",null,null],[12,"sspsr","","Supported Parallel Port Sizes",25,null],[12,"cspsr","","Current Parallel Port Size",25,null],[12,"acpr","","Asynchronous Clock Prescaler",25,null],[12,"sppr","","Selected Pin Control",25,null],[12,"ffcr","","Formatter and Flush Control",25,null],[12,"lar","","Lock Access",25,null],[12,"lsr","","Lock Status",25,null],[12,"_type","","TPIU Type",25,null],[11,"take","cortex_m::peripheral","Returns all the core peripherals once",3,{"inputs":[],"output":{"name":"option"}}],[11,"steal","","Unchecked version of `Peripherals::take`",3,{"inputs":[],"output":{"name":"self"}}],[11,"ptr","","Returns a pointer to the register block",5,null],[11,"deref","","",5,null],[11,"ptr","","Returns a pointer to the register block",8,null],[11,"deref","","",8,null],[11,"ptr","","Returns a pointer to the register block",26,null],[11,"deref","","",26,null],[11,"ptr","","Returns a pointer to the register block",12,null],[11,"deref","","",12,null],[11,"ptr","","Returns a pointer to the register block",27,null],[11,"deref","","",27,null],[11,"ptr","","Returns a pointer to the register block",28,null],[11,"deref","","",28,null],[11,"ptr","","Returns a pointer to the register block",29,null],[11,"deref","","",29,null],[11,"deref_mut","","",29,null],[11,"ptr","","Returns a pointer to the register block",30,null],[11,"deref","","",30,null],[11,"ptr","","Returns a pointer to the register block",19,null],[11,"deref","","",19,null],[11,"ptr","","Returns a pointer to the register block",21,null],[11,"deref","","",21,null],[11,"ptr","","Returns a pointer to the register block",24,null],[11,"deref","","",24,null],[11,"ptr","","Returns a pointer to the register block",31,null],[11,"deref","","",31,null],[0,"register","cortex_m","Processor core registers",null,null],[0,"basepri","cortex_m::register","Base Priority Mask Register",null,null],[5,"read","cortex_m::register::basepri","Reads the CPU register",null,{"inputs":[],"output":{"name":"u8"}}],[5,"write","","Writes to the CPU register",null,{"inputs":[{"name":"u8"}],"output":null}],[0,"basepri_max","cortex_m::register","Base Priority Mask Register (conditional write)",null,null],[5,"write","cortex_m::register::basepri_max","Writes to BASEPRI if",null,{"inputs":[{"name":"u8"}],"output":null}],[0,"control","cortex_m::register","Control register",null,null],[3,"Control","cortex_m::register::control","Control register",null,null],[4,"Npriv","","Thread mode privilege level",null,null],[13,"Privileged","","Privileged",32,null],[13,"Unprivileged","","Unprivileged",32,null],[4,"Spsel","","Currently active stack pointer",null,null],[13,"Msp","","MSP is the current stack pointer",33,null],[13,"Psp","","PSP is the current stack pointer",33,null],[4,"Fpca","","Whether context floating-point is currently active",null,null],[13,"Active","","Floating-point context active.",34,null],[13,"NotActive","","No floating-point context active",34,null],[5,"read","","Reads the CPU register",null,{"inputs":[],"output":{"name":"control"}}],[11,"clone","","",35,{"inputs":[{"name":"self"}],"output":{"name":"control"}}],[11,"fmt","","",35,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"bits","","Returns the contents of the register as raw bits",35,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"npriv","","Thread mode privilege level",35,{"inputs":[{"name":"self"}],"output":{"name":"npriv"}}],[11,"spsel","","Currently active stack pointer",35,{"inputs":[{"name":"self"}],"output":{"name":"spsel"}}],[11,"fpca","","Whether context floating-point is currently active",35,{"inputs":[{"name":"self"}],"output":{"name":"fpca"}}],[11,"clone","","",32,{"inputs":[{"name":"self"}],"output":{"name":"npriv"}}],[11,"fmt","","",32,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",32,{"inputs":[{"name":"self"},{"name":"npriv"}],"output":{"name":"bool"}}],[11,"is_privileged","","Is in privileged thread mode?",32,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_unprivileged","","Is in unprivileged thread mode?",32,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"clone","","",33,{"inputs":[{"name":"self"}],"output":{"name":"spsel"}}],[11,"fmt","","",33,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",33,{"inputs":[{"name":"self"},{"name":"spsel"}],"output":{"name":"bool"}}],[11,"is_msp","","Is MSP the current stack pointer?",33,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_psp","","Is PSP the current stack pointer?",33,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"clone","","",34,{"inputs":[{"name":"self"}],"output":{"name":"fpca"}}],[11,"fmt","","",34,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",34,{"inputs":[{"name":"self"},{"name":"fpca"}],"output":{"name":"bool"}}],[11,"is_active","","Is a floating-point context active?",34,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_not_active","","Is a floating-point context not active?",34,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[0,"faultmask","cortex_m::register","Fault Mask Register",null,null],[4,"Faultmask","cortex_m::register::faultmask","All exceptions are ...",null,null],[13,"Active","","Active",36,null],[13,"Inactive","","Inactive, expect for NMI",36,null],[5,"read","","Reads the CPU register",null,{"inputs":[],"output":{"name":"faultmask"}}],[11,"clone","","",36,{"inputs":[{"name":"self"}],"output":{"name":"faultmask"}}],[11,"fmt","","",36,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",36,{"inputs":[{"name":"self"},{"name":"faultmask"}],"output":{"name":"bool"}}],[11,"is_active","","All exceptions are active",36,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_inactive","","All exceptions, except for NMI, are inactive",36,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[0,"msp","cortex_m::register","Main Stack Pointer",null,null],[5,"read","cortex_m::register::msp","Reads the CPU register",null,{"inputs":[],"output":{"name":"u32"}}],[5,"write","","Writes `bits` to the CPU register",null,{"inputs":[{"name":"u32"}],"output":null}],[0,"primask","cortex_m::register","Priority mask register",null,null],[4,"Primask","cortex_m::register::primask","All exceptions with configurable priority are ...",null,null],[13,"Active","","Active",37,null],[13,"Inactive","","Inactive",37,null],[5,"read","","Reads the CPU register",null,{"inputs":[],"output":{"name":"primask"}}],[11,"clone","","",37,{"inputs":[{"name":"self"}],"output":{"name":"primask"}}],[11,"fmt","","",37,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",37,{"inputs":[{"name":"self"},{"name":"primask"}],"output":{"name":"bool"}}],[11,"is_active","","All exceptions with configurable priority are active",37,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_inactive","","All exceptions with configurable priority are inactive",37,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[0,"psp","cortex_m::register","Process Stack Pointer",null,null],[5,"read","cortex_m::register::psp","Reads the CPU register",null,{"inputs":[],"output":{"name":"u32"}}],[5,"write","","Writes `bits` to the CPU register",null,{"inputs":[{"name":"u32"}],"output":null}],[14,"iprint","cortex_m","Macro for sending a formatted string through an ITM channel",null,null],[14,"iprintln","","Macro for sending a formatted string through an ITM channel, with a newline.",null,null],[11,"new","cortex_m::interrupt","Creates a critical section token",38,{"inputs":[],"output":{"name":"criticalsection"}}],[11,"new","","Creates a new mutex",39,{"inputs":[{"name":"t"}],"output":{"name":"mutex"}}],[11,"borrow","","Borrows the data for the duration of the critical section",39,{"inputs":[{"name":"self"},{"name":"criticalsection"}],"output":{"name":"t"}}]],"paths":[[3,"ExceptionFrame"],[4,"Exception"],[8,"Nr"],[3,"Peripherals"],[3,"RegisterBlock"],[3,"CBP"],[3,"RegisterBlock"],[4,"CsselrCacheType"],[3,"CPUID"],[3,"RegisterBlock"],[3,"RegisterBlock"],[3,"Comparator"],[3,"DWT"],[3,"RegisterBlock"],[3,"RegisterBlock"],[3,"RegisterBlock"],[3,"Stim"],[3,"RegisterBlock"],[3,"RegisterBlock"],[3,"NVIC"],[3,"RegisterBlock"],[3,"SCB"],[3,"RegisterBlock"],[4,"SystClkSource"],[3,"SYST"],[3,"RegisterBlock"],[3,"DCB"],[3,"FPB"],[3,"FPU"],[3,"ITM"],[3,"MPU"],[3,"TPIU"],[4,"Npriv"],[4,"Spsel"],[4,"Fpca"],[3,"Control"],[4,"Faultmask"],[4,"Primask"],[3,"CriticalSection"],[3,"Mutex"]]};
searchIndex["cortex_m_quickstart"] = {"doc":"A template for building applications for ARM Cortex-M microcontrollers","items":[[0,"examples","cortex_m_quickstart","Examples",null,null],[0,"_0_minimal","cortex_m_quickstart::examples","Minimal Cortex-M program",null,null],[0,"_1_hello","","Prints \"Hello, world!\" on the OpenOCD console using semihosting",null,null],[0,"_2_itm","","Sends \"Hello, world!\" through the ITM port 0",null,null],[0,"_3_panic","","Changing the panic handler",null,null],[0,"_4_crash","","Debugging a crash (exception)",null,null],[0,"_5_exception","","Overriding an exception handler",null,null],[0,"_6_device","","Using a device crate",null,null],[0,"_7_allocator","","How to use the heap and a dynamic memory allocator",null,null]],"paths":[]};
searchIndex["cortex_m_rt"] = {"doc":"Minimal startup / runtime for Cortex-M microcontrollers","items":[[3,"ExceptionFrame","cortex_m_rt","Registers stacked (pushed into the stack) during an exception",null,null],[12,"r0","","(General purpose) Register 0",0,null],[12,"r1","","(General purpose) Register 1",0,null],[12,"r2","","(General purpose) Register 2",0,null],[12,"r3","","(General purpose) Register 3",0,null],[12,"r12","","(General purpose) Register 12",0,null],[12,"lr","","Linker Register",0,null],[12,"pc","","Program Counter",0,null],[12,"xpsr","","Program Status Register",0,null],[5,"heap_start","","Returns a pointer into which the heap can be placed",null,null],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"exceptionframe"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[14,"main","","Macro to define the user entry point of a program",null,null],[14,"exception","","Macro to override an exception handler",null,null],[14,"interrupts","","Macro to bind all the 240 interrupt handlers to the `DefaultHandler` exception handler.",null,null]],"paths":[[3,"ExceptionFrame"]]};
searchIndex["cortex_m_semihosting"] = {"doc":"Semihosting for ARM Cortex-M processors","items":[[5,"syscall","cortex_m_semihosting","Performs a semihosting operation, takes a pointer to an argument block",null,{"inputs":[{"name":"usize"},{"name":"t"}],"output":{"name":"usize"}}],[5,"syscall1","","Performs a semihosting operation, takes one integer as an argument",null,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"usize"}}],[0,"debug","","Interacting with debugging agent",null,null],[4,"Exception","cortex_m_semihosting::debug","This values are taken from section 5.5.2 of ADS Debug Target Guide (DUI0058).",null,null],[13,"BranchThroughZero","","",0,null],[13,"UndefinedInstr","","",0,null],[13,"SoftwareInterrupt","","",0,null],[13,"PrefetchAbort","","",0,null],[13,"DataAbort","","",0,null],[13,"AddressException","","",0,null],[13,"IRQ","","",0,null],[13,"FIQ","","",0,null],[13,"BreakPoint","","",0,null],[13,"WatchPoint","","",0,null],[13,"StepComplete","","",0,null],[13,"RunTimeErrorUnknown","","",0,null],[13,"InternalError","","",0,null],[13,"UserInterruption","","",0,null],[13,"ApplicationExit","","",0,null],[13,"StackOverflow","","",0,null],[13,"DivisionByZero","","",0,null],[13,"OSSpecific","","",0,null],[5,"exit","","Reports to the debugger that the execution has completed.",null,{"inputs":[{"name":"exitstatus"}],"output":null}],[5,"report_exception","","Report an exception to the debugger directly.",null,{"inputs":[{"name":"exception"}],"output":null}],[6,"ExitStatus","","Status enum for `exit` syscall.",null,null],[17,"EXIT_SUCCESS","","Successful execution of a program.",null,null],[17,"EXIT_FAILURE","","Unsuccessful execution of a program.",null,null],[0,"hio","cortex_m_semihosting","Host I/O",null,null],[3,"HStderr","cortex_m_semihosting::hio","Host's standard error",null,null],[3,"HStdout","","Host's standard output",null,null],[5,"hstderr","","Construct a new handle to the host's standard error.",null,{"inputs":[],"output":{"generics":["hstderr"],"name":"result"}}],[5,"hstdout","","Construct a new handle to the host's standard output.",null,{"inputs":[],"output":{"generics":["hstdout"],"name":"result"}}],[11,"write_all","","Attempts to write an entire `buffer` into this sink",1,null],[11,"write_str","","",1,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"result"}}],[11,"write_all","","Attempts to write an entire `buffer` into this sink",2,null],[11,"write_str","","",2,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"result"}}],[0,"nr","cortex_m_semihosting","Semihosting operations",null,null],[0,"open","cortex_m_semihosting::nr","Values for the mode parameter of the OPEN syscall.",null,null],[17,"R","cortex_m_semihosting::nr::open","Mode corresponding to fopen \"r\" mode.",null,null],[17,"R_BINARY","","Mode corresponding to fopen \"rb\" mode.",null,null],[17,"RW","","Mode corresponding to fopen \"r+\" mode.",null,null],[17,"RW_BINARY","","Mode corresponding to fopen \"r+b\" mode.",null,null],[17,"W_TRUNC","","Mode corresponding to fopen \"w\" mode.",null,null],[17,"W_TRUNC_BINARY","","Mode corresponding to fopen \"wb\" mode.",null,null],[17,"RW_TRUNC","","Mode corresponding to fopen \"w+\" mode.",null,null],[17,"RW_TRUNC_BINARY","","Mode corresponding to fopen \"w+b\" mode.",null,null],[17,"W_APPEND","","Mode corresponding to fopen \"a\" mode.",null,null],[17,"W_APPEND_BINARY","","Mode corresponding to fopen \"ab\" mode.",null,null],[17,"RW_APPEND","","Mode corresponding to fopen \"a+\" mode.",null,null],[17,"RW_APPEND_BINARY","","Mode corresponding to fopen \"a+b\" mode.",null,null],[17,"CLOCK","cortex_m_semihosting::nr","",null,null],[17,"CLOSE","","",null,null],[17,"ELAPSED","","",null,null],[17,"ERRNO","","",null,null],[17,"FLEN","","",null,null],[17,"GET_CMDLINE","","",null,null],[17,"HEAPINFO","","",null,null],[17,"ISERROR","","",null,null],[17,"ISTTY","","",null,null],[17,"OPEN","","",null,null],[17,"READ","","",null,null],[17,"READC","","",null,null],[17,"REMOVE","","",null,null],[17,"RENAME","","",null,null],[17,"SEEK","","",null,null],[17,"SYSTEM","","",null,null],[17,"TICKFREQ","","",null,null],[17,"TIME","","",null,null],[17,"TMPNAM","","",null,null],[17,"WRITE0","","",null,null],[17,"WRITE","","",null,null],[17,"WRITEC","","",null,null],[17,"ENTER_SVC","","",null,null],[17,"REPORT_EXCEPTION","","",null,null],[14,"syscall","cortex_m_semihosting","Variable argument version of `syscall`",null,null],[14,"syscall1","","Macro version of `syscall1`",null,null]],"paths":[[4,"Exception"],[3,"HStderr"],[3,"HStdout"]]};
searchIndex["linked_list_allocator"] = {"doc":"","items":[[3,"Heap","linked_list_allocator","A fixed size heap backed by a linked list of free memory blocks.",null,null],[5,"align_down","","Align downwards. Returns the greatest x with alignment `align` so that x <= addr. The alignment must be a power of 2.",null,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"usize"}}],[5,"align_up","","Align upwards. Returns the smallest x with alignment `align` so that x >= addr. The alignment must be a power of 2.",null,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"usize"}}],[11,"empty","","Creates an empty heap. All allocate calls will return `None`.",0,{"inputs":[],"output":{"name":"heap"}}],[11,"init","","Initializes an empty heap",0,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"}],"output":null}],[11,"new","","Creates a new heap with the given `bottom` and `size`. The bottom address must be valid and the memory in the `[heap_bottom, heap_bottom + heap_size)` range must not be used for anything else. This function is unsafe because it can cause undefined behavior if the given address is invalid.",0,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"heap"}}],[11,"allocate_first_fit","","Allocates a chunk of the given size with the given alignment. Returns a pointer to the beginning of that chunk if it was successful. Else it returns `None`. This function scans the list of free memory blocks and uses the first block that is big enough. The runtime is in O(n) where n is the number of free blocks, but it should be reasonably fast for small allocations.",0,{"inputs":[{"name":"self"},{"name":"layout"}],"output":{"generics":["nonnull","allocerr"],"name":"result"}}],[11,"deallocate","","Frees the given allocation. `ptr` must be a pointer returned by a call to the `allocate_first_fit` function with identical size and alignment. Undefined behavior may occur for invalid arguments, thus this function is unsafe.",0,{"inputs":[{"name":"self"},{"generics":["opaque"],"name":"nonnull"},{"name":"layout"}],"output":null}],[11,"bottom","","Returns the bottom address of the heap.",0,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"size","","Returns the size of the heap.",0,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"top","","Return the top address of the heap",0,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"extend","","Extends the size of the heap by creating a new hole at the end",0,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"alloc","","",0,{"inputs":[{"name":"self"},{"name":"layout"}],"output":{"generics":["nonnull","allocerr"],"name":"result"}}],[11,"dealloc","","",0,{"inputs":[{"name":"self"},{"generics":["opaque"],"name":"nonnull"},{"name":"layout"}],"output":null}],[11,"oom","","",0,null]],"paths":[[3,"Heap"]]};
searchIndex["panic_abort"] = {"doc":"Set the panicking behavior to abort","items":[],"paths":[]};
searchIndex["panic_semihosting"] = {"doc":"Report panic messages to the host stderr using semihosting","items":[],"paths":[]};
searchIndex["r0"] = {"doc":"Initialization code (\"crt0\") written in Rust","items":[[5,"init_data","r0","Initializes the `.data` section",null,null],[5,"run_init_array","","",null,null],[5,"zero_bss","","Zeroes the `.bss` section",null,null],[14,"pre_init_array","","",null,null],[14,"init_array","","",null,null]],"paths":[]};
searchIndex["vcell"] = {"doc":"Just like [`Cell`] but with [volatile] read / write operations","items":[[3,"VolatileCell","vcell","Just like [`Cell`] but with [volatile] read / write operations",null,null],[11,"new","","Creates a new `VolatileCell` containing the given value",0,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[11,"get","","Returns a copy of the contained value",0,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"set","","Sets the contained value",0,{"inputs":[{"name":"self"},{"name":"t"}],"output":null}]],"paths":[[3,"VolatileCell"]]};
searchIndex["volatile_register"] = {"doc":"Volatile access to memory mapped hardware registers","items":[[3,"RO","volatile_register","Read-Only register",null,null],[3,"RW","","Read-Write register",null,null],[3,"WO","","Write-Only register",null,null],[11,"read","","Reads the value of the register",0,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"modify","","Performs a read-modify-write operation",1,{"inputs":[{"name":"self"},{"name":"f"}],"output":null}],[11,"read","","Reads the value of the register",1,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"write","","Writes a `value` into the register",1,{"inputs":[{"name":"self"},{"name":"t"}],"output":null}],[11,"write","","Writes `value` into the register",2,{"inputs":[{"name":"self"},{"name":"t"}],"output":null}]],"paths":[[3,"RO"],[3,"RW"],[3,"WO"]]};
initSearch(searchIndex);
